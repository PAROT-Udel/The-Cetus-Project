
	Reduction analysis pass output:
	

	#include <stdio.h>
	int main()
	{
		int len;
		double a[len], b[len], c[len];
		int i, j;
		int _ret_val_0;
		len=100;
		j=0;
		
		#pragma cetus private(i) 
		#pragma loop name main#0 
		for (i=0; i<len; i ++ )
		{
			a[i]=(((double)i)/2.0);
			b[i]=(((double)i)/3.0);
			c[i]=(((double)i)/7.0);
		}
		
		#pragma cetus private(i) 
		#pragma loop name main#1 
		#pragma cetus reduction(+: c[i+j]) 
		for (i=0; i<len; i ++ )
		{
			c[i+j]+=(a[i]*b[i]);
		}
		
		if ((-1+len)>=0)
		{
			j+=len;
		}
		printf("c[50]=%f\n", c[50]);
		_ret_val_0=0;
		return _ret_val_0;
	}



	When parallelize-loops=1(parallelize outermost loops), the loop parallelization pass
	invokes Reduction Transformation which gives the following output that crashes the Cetus
	OpenMP generator pass.

	#include <stdio.h>
	int main()
	{
		int len;
		double a[len], b[len], c[len];
		int i, j;
		int _ret_val_0;
		len=100;
		j=0;
		#pragma cetus private(i) 
		#pragma loop name main#0 
		#pragma cetus parallel 
		#pragma omp parallel for private(i)
		for (i=0; i<len; i ++ )
		{
			a[i]=(((double)i)/2.0);
			b[i]=(((double)i)/3.0);
			c[i]=(((double)i)/7.0);
		}
		
		#pragma cetus parallel 
		#pragma cetus private(i) 
		#pragma omp parallel private(i)
		{
			double * reduce = (double * )malloc(len*sizeof (double));
			int reduce_span_0;
			for (reduce_span_0=0; reduce_span_0<len; reduce_span_0 ++ )
			{
				reduce[reduce_span_0]=0;
			}
			
			#pragma loop name main#1 
			#pragma cetus for  
			#pragma omp for
			for (i=0; i<len; i ++ )
			{
				reduce[i+j]+=(a[i]*b[i]);
			}
			#pragma cetus critical  
			#pragma omp critical
			{
				for (reduce_span_0=0; reduce_span_0<len; reduce_span_0 ++ )
				{
					c[reduce_span_0]+=reduce[reduce_span_0];
				}
			}
		}
		if ((-1+len)>=0)
		{
			j+=len;
		}
		printf("c[50]=%f\n", c[50]);
		_ret_val_0=0;
		return _ret_val_0;
	}
	
	
	With parallelize-loops=2, loop parallelization does not invoke reduction transformation,
	and following is the Cetus output:


	#include <stdio.h>
	int main()
	{
		int len;
		double a[len], b[len], c[len];
		int i, j;
		int _ret_val_0;
		len=100;
		j=0;
		#pragma cetus private(i) 
		#pragma loop name main#0 
		#pragma cetus parallel 
		#pragma omp parallel for if((10000<(1L+(5L*len)))) private(i)
		for (i=0; i<len; i ++ )
		{
			a[i]=(((double)i)/2.0);
			b[i]=(((double)i)/3.0);
			c[i]=(((double)i)/7.0);
		}
		#pragma cetus private(i) 
		#pragma loop name main#1 
		#pragma cetus reduction(+: c[i+j]) 
		#pragma cetus parallel 
		#pragma omp parallel for if((10000<(1L+(3L*len)))) private(i) reduction(+: c[i+j])
		for (i=0; i<len; i ++ )
		{
			c[i+j]+=(a[i]*b[i]);
		}
		if ((-1+len)>=0)
		{
			j+=len;
		}
		printf("c[50]=%f\n", c[50]);
		_ret_val_0=0;
		return _ret_val_0;
	}

	
	
	
	

